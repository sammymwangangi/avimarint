{"version":3,"file":"vue-currency-filter.js","sources":["../src/utils.ts","../src/accounting.ts","../src/index.ts"],"sourcesContent":["const nativeMap = Array.prototype.map\nconst nativeIsArray = Array.isArray\nconst toString = Object.prototype.toString\n\nexport function __isNull(obj: any): boolean {\n  return typeof obj === 'undefined' || obj === null\n};\n\nexport function __isString(obj: any): boolean {\n  return !!(obj === '' || (obj && obj.charCodeAt && obj.substr))\n};\n\nexport function __isArray(obj: any): boolean {\n  return nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === '[object Array]'\n};\n\nexport function __isObject(obj: any): boolean {\n  return obj && toString.call(obj) === '[object Object]'\n};\n\nexport function __defaults(object, defs) {\n  var key\n  object = object || {}\n  defs = defs || {}\n  // Iterate over object non-prototype properties:\n  for (key in defs) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (defs.hasOwnProperty(key)) {\n      // Replace values with defaults only if undefined (allow empty/zero values):\n      if (object[key] == null) object[key] = defs[key]\n    }\n  }\n  return object\n};\n\nexport function __map(obj, iterator, context?) {\n  if (!obj) return []\n  // Use native .map method if it exists:\n  if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context)\n\n  const results = []\n  let i = 0\n  let j = 0\n  // Fallback for native .map:\n  for (i = 0, j = obj.length; i < j; i++) {\n    // @ts-ignore\n    results[i] = iterator.call(context, obj[i], i, obj)\n  }\n  return results\n}\n","import { __isString, __isArray, __map, __defaults, __isObject } from './utils'\n\nconst lib = {\n  settings: {\n    currency: {\n      symbol: '$', // default currency symbol is '$'\n      format: '%s%v', // controls output: %s = symbol, %v = value (can be object, see docs)\n      decimal: '.', // decimal point separator\n      thousand: ',', // thousands separator\n      precision: 2, // decimal places\n      grouping: 3 // digit grouping (not implemented yet)\n    },\n    number: {\n      precision: 0, // default precision on numbers is 0\n      grouping: 3, // digit grouping (not implemented yet)\n      thousand: ',',\n      decimal: '.'\n    }\n  }\n}\n\n/**\n * Check and normalise the value of precision (must be positive integer)\n */\nexport function checkPrecision(val, base = 0) {\n  val = Math.round(Math.abs(val))\n  return isNaN(val) ? base : val\n}\n\n/**\n * Parses a format string or object and returns format obj for use in rendering\n *\n * `format` is either a string with the default (positive) format, or object\n * containing `pos` (required), `neg` and `zero` values (or a function returning\n * either a string or object)\n *\n * Either string or format.pos must contain \"%v\" (value) to be valid\n */\nexport function checkCurrencyFormat(format) {\n  var defaults = lib.settings.currency.format\n\n  // Allow function as format parameter (should return string or object):\n  if (typeof format === 'function') format = format()\n\n  // Format can be a string, in which case `value` (\"%v\") must be present:\n  if (__isString(format) && format.match('%v')) {\n    // Create and return positive, negative and zero formats:\n    return {\n      pos: format,\n      neg: format.replace('-', '').replace('%v', '-%v'),\n      zero: format\n    }\n\n    // If no format, or object is missing valid positive value, use defaults:\n  } else if (!format || !format.pos || !format.pos.match('%v')) {\n    // If defaults is a string, casts it to an object for faster checking next time:\n    return !__isString(defaults)\n      ? defaults\n      // @ts-ignore\n      : (lib.settings.currency.format = {\n        pos: defaults,\n        neg: defaults.replace('%v', '-%v'),\n        zero: defaults\n      })\n  }\n  // Otherwise, assume format was fine:\n  return format\n}\n\nexport const unformat = function (value, decimal?) {\n  // Recursively unformat arrays:\n  if (__isArray(value)) {\n    return __map(value, function (val) {\n      return unformat(val, decimal)\n    })\n  }\n\n  // Fails silently (need decent errors):\n  value = value || 0\n\n  // Return the value as-is if it's already a number:\n  if (typeof value === 'number') return value\n\n  // Default decimal point comes from settings, but could be set to eg. \",\" in opts:\n  decimal = decimal || lib.settings.number.decimal\n\n  // Build regex to strip out everything except digits, decimal point and minus sign:\n  // @ts-ignore\n  var regex = new RegExp('[^0-9-' + decimal + ']', ['g'])\n  var unformatted = parseFloat(\n    ('' + value)\n      .replace(/\\((?=\\d+)(.*)\\)/, '-$1') // replace bracketed values with negatives\n      .replace(regex, '') // strip out any cruft\n      .replace(decimal, '.') // make sure decimal point is standard\n  )\n\n  // This will fail silently which may cause trouble, let's wait and see:\n  return !isNaN(unformatted) ? unformatted : 0\n}\n\n/**\n * Implementation of toFixed() that treats floats more like decimals\n *\n * Fixes binary rounding issues (eg. (0.615).toFixed(2) === \"0.61\") that present\n * problems for accounting- and finance-related software.\n */\nexport const toFixed = function (value, precision) {\n  precision = checkPrecision(precision, lib.settings.number.precision)\n\n  var exponentialForm = Number(unformat(value) + 'e' + precision)\n  var rounded = Math.round(exponentialForm)\n  var finalResult = Number(rounded + 'e-' + precision).toFixed(precision)\n  return finalResult\n}\n\n/**\n * Format a number, with comma-separated thousands and custom precision/decimal places\n * Alias: `accounting.format()`\n *\n * Localise by overriding the precision and thousand / decimal separators\n * 2nd parameter `precision` can be an object matching `settings.number`\n */\nexport const formatNumber = function (\n  number,\n  precision,\n  thousand,\n  decimal,\n  avoidEmptyDecimals\n) {\n  // Resursively format arrays:\n  if (__isArray(number)) {\n    return __map(number, function (val) {\n      return formatNumber(val, precision, thousand, decimal, avoidEmptyDecimals)\n    })\n  }\n\n  // Clean up number:\n  number = unformat(number)\n\n  // Build options object from second param (if object) or all params, extending defaults:\n  var opts = __defaults(\n    __isObject(precision)\n      ? precision\n      : {\n        precision: precision,\n        thousand: thousand,\n        decimal: decimal\n      },\n    lib.settings.number\n  )\n  // Clean up precision\n  var usePrecision = checkPrecision(opts.precision)\n  // Do some calc:\n  var negative = number < 0 ? '-' : ''\n  var base = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + ''\n  var mod = base.length > 3 ? base.length % 3 : 0\n\n  var precisionString = ''\n  if (usePrecision) {\n    // default behaviour\n    // 1234.56 and avoidEmptyDecimals whatever   => 1234.56\n    // 1234.00 and avoidEmptyDecimals undefined  => 1234.00\n    precisionString = opts.decimal + toFixed(Math.abs(number), usePrecision).split('.')[1]\n\n    // 1234.00 and avoidEmptyDecimals == ''    => 1234\n    // 1234.00 and avoidEmptyDecimals == '##'  => 1234.##\n    if (avoidEmptyDecimals !== undefined && parseInt(toFixed(Math.abs(number || 0), 1), 10) == number) {\n      precisionString = avoidEmptyDecimals === '' ? '' : opts.decimal + avoidEmptyDecimals\n    }\n  }\n\n  // Format the number:\n  return (\n    negative +\n    (mod ? base.substr(0, mod) + opts.thousand : '') +\n    base.substr(mod).replace(/(\\d{3})(?=\\d)/g, '$1' + opts.thousand) +\n    precisionString\n  )\n}\n\n/**\n * Format a number into currency\n *\n * Usage: accounting.formatMoney(number, symbol, precision, thousandsSep, decimalSep, format)\n * defaults: (0, \"$\", 2, \",\", \".\", \"%s%v\")\n *\n * Localise by overriding the symbol, precision, thousand / decimal separators and format\n * Second param can be an object matching `settings.currency` which is the easiest way.\n *\n * To do: tidy up the parameters\n */\nexport const formatMoney = function (\n  number,\n  symbol,\n  precision,\n  thousand,\n  decimal,\n  format,\n  avoidEmptyDecimals\n) {\n  // Resursively format arrays:\n  if (__isArray(number)) {\n    return __map(number, function (val) {\n      return formatMoney(val, symbol, precision, thousand, decimal, format, avoidEmptyDecimals)\n    })\n  }\n\n  // Clean up number:\n  number = unformat(number)\n\n  // Build options object from second param (if object) or all params, extending defaults:\n  var opts = __defaults(\n    __isObject(symbol)\n      ? symbol\n      : {\n        symbol: symbol,\n        precision: precision,\n        thousand: thousand,\n        decimal: decimal,\n        format: format,\n        avoidEmptyDecimals: avoidEmptyDecimals,\n      },\n    lib.settings.currency\n  )\n  // Check format (returns object with pos, neg and zero):\n  var formats = checkCurrencyFormat(opts.format)\n  // Choose which format to use for this value:\n  var useFormat =\n    number > 0 ? formats.pos : number < 0 ? formats.neg : formats.zero\n\n  // Return with currency symbol added:\n  return useFormat\n    .replace('%s', opts.symbol)\n    .replace(\n      '%v',\n      formatNumber(\n        Math.abs(number),\n        checkPrecision(opts.precision),\n        opts.thousand,\n        opts.decimal,\n        opts.avoidEmptyDecimals\n      )\n    )\n}\n","import { toFixed, formatMoney } from './accounting'\nimport { __isNull, __defaults } from './utils'\nimport { PluginObject } from 'vue'\nimport { CurrencyFilterMethodInstance, currencyOptions } from './types';\n\nconst defaultConfig: currencyOptions = {\n  name: 'currency',\n  symbol: '',\n  thousandsSeparator: '.',\n  fractionCount: 0,\n  fractionSeparator: ',',\n  symbolPosition: 'front',\n  symbolSpacing: true,\n  avoidEmptyDecimals: undefined,\n}\n\nconst VueCurrencyFilter: PluginObject<currencyOptions[] | currencyOptions> = {\n  install(Vue, pluginOptions) {\n    const createFilter = (options: currencyOptions) => {\n      if (__isNull(options)) options = {}\n      const globalConfigs = __defaults(options, defaultConfig)\n      let { name, ...configs } = globalConfigs\n\n      const filterCurrency = function (value: string,\n        _symbol?: string,\n        _thousandsSeparator?: string,\n        _fractionCount?: number,\n        _fractionSeparator?: string,\n        _symbolPosition?: string,\n        _symbolSpacing?: boolean,\n        _avoidEmptyDecimals?: string): string | number {\n\n        let runtimeConfig = __defaults({\n          symbol: _symbol,\n          thousandsSeparator: _thousandsSeparator,\n          fractionCount: _fractionCount,\n          fractionSeparator: _fractionSeparator,\n          symbolPosition: _symbolPosition,\n          symbolSpacing: _symbolSpacing,\n          avoidEmptyDecimals: _avoidEmptyDecimals\n        }, configs)\n\n        if (typeof _symbol === 'object') {\n          runtimeConfig = __defaults(_symbol, configs)\n        }\n\n        let result = 0.0\n        const isNegative = String(value).charAt(0) === '-'\n\n        if (isNegative) {\n          value = String(value).slice(1)\n        }\n\n        const amount = parseFloat(value)\n        if (!isNaN(amount)) {\n          result = amount\n        }\n\n        let formatConfig = '%s%v'\n        if (runtimeConfig.symbolPosition === 'front') {\n          formatConfig = runtimeConfig.symbolSpacing ? '%s %v' : '%s%v'\n        } else {\n          formatConfig = runtimeConfig.symbolSpacing ? '%v %s' : '%v%s'\n        }\n\n        if (runtimeConfig.fractionCount > 0) {\n          value = toFixed(value, runtimeConfig.fractionCount)\n        }\n\n        // @ts-ignore\n        result = formatMoney(value, {\n          format: formatConfig,\n          symbol: runtimeConfig.symbol,\n          precision: runtimeConfig.fractionCount,\n          thousand: runtimeConfig.thousandsSeparator,\n          decimal: runtimeConfig.fractionSeparator,\n          avoidEmptyDecimals: runtimeConfig.avoidEmptyDecimals,\n        })\n\n        if (isNegative) {\n          // @ts-ignore\n          result = '-' + result\n        }\n\n        return result\n      }\n\n      Vue.filter(name, filterCurrency)\n      Vue.prototype['$' + name] = {\n        setConfig: (options) => {\n          configs = __defaults(options, defaultConfig)\n        },\n        getConfig: () => {\n          return configs\n        },\n        format: filterCurrency\n      } as CurrencyFilterMethodInstance\n    }\n\n    if (Array.isArray(pluginOptions)) {\n      pluginOptions.forEach(options => createFilter(options))\n    } else {\n      createFilter(pluginOptions!)\n    }\n  }\n}\n\nexport default VueCurrencyFilter\n"],"names":["nativeMap","Array","prototype","map","nativeIsArray","isArray","toString","Object","__isString","obj","charCodeAt","substr","__isArray","call","__isObject","__defaults","object","defs","key","hasOwnProperty","__map","iterator","context","j","results","i","length","lib","settings","currency","symbol","format","decimal","thousand","precision","grouping","number","checkPrecision","val","base","Math","round","abs","isNaN","unformat","value","regex","RegExp","unformatted","parseFloat","replace","toFixed","exponentialForm","Number","rounded","defaultConfig","name","thousandsSeparator","fractionCount","fractionSeparator","symbolPosition","symbolSpacing","avoidEmptyDecimals","undefined","install","Vue","pluginOptions","createFilter","options","globalConfigs","configs","filterCurrency","_symbol","_thousandsSeparator","_fractionCount","_fractionSeparator","_symbolPosition","_symbolSpacing","_avoidEmptyDecimals","runtimeConfig","result","isNegative","String","charAt","slice","formatConfig","amount","formatMoney","opts","formats","defaults","match","pos","neg","zero","checkCurrencyFormat","formatNumber","usePrecision","negative","parseInt","mod","precisionString","split","filter","setConfig","getConfig","forEach"],"mappings":"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"}