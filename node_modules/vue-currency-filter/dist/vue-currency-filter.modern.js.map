{"version":3,"file":"vue-currency-filter.modern.js","sources":["../src/utils.ts","../src/accounting.ts","../src/index.ts"],"sourcesContent":["const nativeMap = Array.prototype.map\nconst nativeIsArray = Array.isArray\nconst toString = Object.prototype.toString\n\nexport function __isNull(obj: any): boolean {\n  return typeof obj === 'undefined' || obj === null\n};\n\nexport function __isString(obj: any): boolean {\n  return !!(obj === '' || (obj && obj.charCodeAt && obj.substr))\n};\n\nexport function __isArray(obj: any): boolean {\n  return nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === '[object Array]'\n};\n\nexport function __isObject(obj: any): boolean {\n  return obj && toString.call(obj) === '[object Object]'\n};\n\nexport function __defaults(object, defs) {\n  var key\n  object = object || {}\n  defs = defs || {}\n  // Iterate over object non-prototype properties:\n  for (key in defs) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (defs.hasOwnProperty(key)) {\n      // Replace values with defaults only if undefined (allow empty/zero values):\n      if (object[key] == null) object[key] = defs[key]\n    }\n  }\n  return object\n};\n\nexport function __map(obj, iterator, context?) {\n  if (!obj) return []\n  // Use native .map method if it exists:\n  if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context)\n\n  const results = []\n  let i = 0\n  let j = 0\n  // Fallback for native .map:\n  for (i = 0, j = obj.length; i < j; i++) {\n    // @ts-ignore\n    results[i] = iterator.call(context, obj[i], i, obj)\n  }\n  return results\n}\n","import { __isString, __isArray, __map, __defaults, __isObject } from './utils'\n\nconst lib = {\n  settings: {\n    currency: {\n      symbol: '$', // default currency symbol is '$'\n      format: '%s%v', // controls output: %s = symbol, %v = value (can be object, see docs)\n      decimal: '.', // decimal point separator\n      thousand: ',', // thousands separator\n      precision: 2, // decimal places\n      grouping: 3 // digit grouping (not implemented yet)\n    },\n    number: {\n      precision: 0, // default precision on numbers is 0\n      grouping: 3, // digit grouping (not implemented yet)\n      thousand: ',',\n      decimal: '.'\n    }\n  }\n}\n\n/**\n * Check and normalise the value of precision (must be positive integer)\n */\nexport function checkPrecision(val, base = 0) {\n  val = Math.round(Math.abs(val))\n  return isNaN(val) ? base : val\n}\n\n/**\n * Parses a format string or object and returns format obj for use in rendering\n *\n * `format` is either a string with the default (positive) format, or object\n * containing `pos` (required), `neg` and `zero` values (or a function returning\n * either a string or object)\n *\n * Either string or format.pos must contain \"%v\" (value) to be valid\n */\nexport function checkCurrencyFormat(format) {\n  var defaults = lib.settings.currency.format\n\n  // Allow function as format parameter (should return string or object):\n  if (typeof format === 'function') format = format()\n\n  // Format can be a string, in which case `value` (\"%v\") must be present:\n  if (__isString(format) && format.match('%v')) {\n    // Create and return positive, negative and zero formats:\n    return {\n      pos: format,\n      neg: format.replace('-', '').replace('%v', '-%v'),\n      zero: format\n    }\n\n    // If no format, or object is missing valid positive value, use defaults:\n  } else if (!format || !format.pos || !format.pos.match('%v')) {\n    // If defaults is a string, casts it to an object for faster checking next time:\n    return !__isString(defaults)\n      ? defaults\n      // @ts-ignore\n      : (lib.settings.currency.format = {\n        pos: defaults,\n        neg: defaults.replace('%v', '-%v'),\n        zero: defaults\n      })\n  }\n  // Otherwise, assume format was fine:\n  return format\n}\n\nexport const unformat = function (value, decimal?) {\n  // Recursively unformat arrays:\n  if (__isArray(value)) {\n    return __map(value, function (val) {\n      return unformat(val, decimal)\n    })\n  }\n\n  // Fails silently (need decent errors):\n  value = value || 0\n\n  // Return the value as-is if it's already a number:\n  if (typeof value === 'number') return value\n\n  // Default decimal point comes from settings, but could be set to eg. \",\" in opts:\n  decimal = decimal || lib.settings.number.decimal\n\n  // Build regex to strip out everything except digits, decimal point and minus sign:\n  // @ts-ignore\n  var regex = new RegExp('[^0-9-' + decimal + ']', ['g'])\n  var unformatted = parseFloat(\n    ('' + value)\n      .replace(/\\((?=\\d+)(.*)\\)/, '-$1') // replace bracketed values with negatives\n      .replace(regex, '') // strip out any cruft\n      .replace(decimal, '.') // make sure decimal point is standard\n  )\n\n  // This will fail silently which may cause trouble, let's wait and see:\n  return !isNaN(unformatted) ? unformatted : 0\n}\n\n/**\n * Implementation of toFixed() that treats floats more like decimals\n *\n * Fixes binary rounding issues (eg. (0.615).toFixed(2) === \"0.61\") that present\n * problems for accounting- and finance-related software.\n */\nexport const toFixed = function (value, precision) {\n  precision = checkPrecision(precision, lib.settings.number.precision)\n\n  var exponentialForm = Number(unformat(value) + 'e' + precision)\n  var rounded = Math.round(exponentialForm)\n  var finalResult = Number(rounded + 'e-' + precision).toFixed(precision)\n  return finalResult\n}\n\n/**\n * Format a number, with comma-separated thousands and custom precision/decimal places\n * Alias: `accounting.format()`\n *\n * Localise by overriding the precision and thousand / decimal separators\n * 2nd parameter `precision` can be an object matching `settings.number`\n */\nexport const formatNumber = function (\n  number,\n  precision,\n  thousand,\n  decimal,\n  avoidEmptyDecimals\n) {\n  // Resursively format arrays:\n  if (__isArray(number)) {\n    return __map(number, function (val) {\n      return formatNumber(val, precision, thousand, decimal, avoidEmptyDecimals)\n    })\n  }\n\n  // Clean up number:\n  number = unformat(number)\n\n  // Build options object from second param (if object) or all params, extending defaults:\n  var opts = __defaults(\n    __isObject(precision)\n      ? precision\n      : {\n        precision: precision,\n        thousand: thousand,\n        decimal: decimal\n      },\n    lib.settings.number\n  )\n  // Clean up precision\n  var usePrecision = checkPrecision(opts.precision)\n  // Do some calc:\n  var negative = number < 0 ? '-' : ''\n  var base = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + ''\n  var mod = base.length > 3 ? base.length % 3 : 0\n\n  var precisionString = ''\n  if (usePrecision) {\n    // default behaviour\n    // 1234.56 and avoidEmptyDecimals whatever   => 1234.56\n    // 1234.00 and avoidEmptyDecimals undefined  => 1234.00\n    precisionString = opts.decimal + toFixed(Math.abs(number), usePrecision).split('.')[1]\n\n    // 1234.00 and avoidEmptyDecimals == ''    => 1234\n    // 1234.00 and avoidEmptyDecimals == '##'  => 1234.##\n    if (avoidEmptyDecimals !== undefined && parseInt(toFixed(Math.abs(number || 0), 1), 10) == number) {\n      precisionString = avoidEmptyDecimals === '' ? '' : opts.decimal + avoidEmptyDecimals\n    }\n  }\n\n  // Format the number:\n  return (\n    negative +\n    (mod ? base.substr(0, mod) + opts.thousand : '') +\n    base.substr(mod).replace(/(\\d{3})(?=\\d)/g, '$1' + opts.thousand) +\n    precisionString\n  )\n}\n\n/**\n * Format a number into currency\n *\n * Usage: accounting.formatMoney(number, symbol, precision, thousandsSep, decimalSep, format)\n * defaults: (0, \"$\", 2, \",\", \".\", \"%s%v\")\n *\n * Localise by overriding the symbol, precision, thousand / decimal separators and format\n * Second param can be an object matching `settings.currency` which is the easiest way.\n *\n * To do: tidy up the parameters\n */\nexport const formatMoney = function (\n  number,\n  symbol,\n  precision,\n  thousand,\n  decimal,\n  format,\n  avoidEmptyDecimals\n) {\n  // Resursively format arrays:\n  if (__isArray(number)) {\n    return __map(number, function (val) {\n      return formatMoney(val, symbol, precision, thousand, decimal, format, avoidEmptyDecimals)\n    })\n  }\n\n  // Clean up number:\n  number = unformat(number)\n\n  // Build options object from second param (if object) or all params, extending defaults:\n  var opts = __defaults(\n    __isObject(symbol)\n      ? symbol\n      : {\n        symbol: symbol,\n        precision: precision,\n        thousand: thousand,\n        decimal: decimal,\n        format: format,\n        avoidEmptyDecimals: avoidEmptyDecimals,\n      },\n    lib.settings.currency\n  )\n  // Check format (returns object with pos, neg and zero):\n  var formats = checkCurrencyFormat(opts.format)\n  // Choose which format to use for this value:\n  var useFormat =\n    number > 0 ? formats.pos : number < 0 ? formats.neg : formats.zero\n\n  // Return with currency symbol added:\n  return useFormat\n    .replace('%s', opts.symbol)\n    .replace(\n      '%v',\n      formatNumber(\n        Math.abs(number),\n        checkPrecision(opts.precision),\n        opts.thousand,\n        opts.decimal,\n        opts.avoidEmptyDecimals\n      )\n    )\n}\n","import { toFixed, formatMoney } from './accounting'\nimport { __isNull, __defaults } from './utils'\nimport { PluginObject } from 'vue'\nimport { CurrencyFilterMethodInstance, currencyOptions } from './types';\n\nconst defaultConfig: currencyOptions = {\n  name: 'currency',\n  symbol: '',\n  thousandsSeparator: '.',\n  fractionCount: 0,\n  fractionSeparator: ',',\n  symbolPosition: 'front',\n  symbolSpacing: true,\n  avoidEmptyDecimals: undefined,\n}\n\nconst VueCurrencyFilter: PluginObject<currencyOptions[] | currencyOptions> = {\n  install(Vue, pluginOptions) {\n    const createFilter = (options: currencyOptions) => {\n      if (__isNull(options)) options = {}\n      const globalConfigs = __defaults(options, defaultConfig)\n      let { name, ...configs } = globalConfigs\n\n      const filterCurrency = function (value: string,\n        _symbol?: string,\n        _thousandsSeparator?: string,\n        _fractionCount?: number,\n        _fractionSeparator?: string,\n        _symbolPosition?: string,\n        _symbolSpacing?: boolean,\n        _avoidEmptyDecimals?: string): string | number {\n\n        let runtimeConfig = __defaults({\n          symbol: _symbol,\n          thousandsSeparator: _thousandsSeparator,\n          fractionCount: _fractionCount,\n          fractionSeparator: _fractionSeparator,\n          symbolPosition: _symbolPosition,\n          symbolSpacing: _symbolSpacing,\n          avoidEmptyDecimals: _avoidEmptyDecimals\n        }, configs)\n\n        if (typeof _symbol === 'object') {\n          runtimeConfig = __defaults(_symbol, configs)\n        }\n\n        let result = 0.0\n        const isNegative = String(value).charAt(0) === '-'\n\n        if (isNegative) {\n          value = String(value).slice(1)\n        }\n\n        const amount = parseFloat(value)\n        if (!isNaN(amount)) {\n          result = amount\n        }\n\n        let formatConfig = '%s%v'\n        if (runtimeConfig.symbolPosition === 'front') {\n          formatConfig = runtimeConfig.symbolSpacing ? '%s %v' : '%s%v'\n        } else {\n          formatConfig = runtimeConfig.symbolSpacing ? '%v %s' : '%v%s'\n        }\n\n        if (runtimeConfig.fractionCount > 0) {\n          value = toFixed(value, runtimeConfig.fractionCount)\n        }\n\n        // @ts-ignore\n        result = formatMoney(value, {\n          format: formatConfig,\n          symbol: runtimeConfig.symbol,\n          precision: runtimeConfig.fractionCount,\n          thousand: runtimeConfig.thousandsSeparator,\n          decimal: runtimeConfig.fractionSeparator,\n          avoidEmptyDecimals: runtimeConfig.avoidEmptyDecimals,\n        })\n\n        if (isNegative) {\n          // @ts-ignore\n          result = '-' + result\n        }\n\n        return result\n      }\n\n      Vue.filter(name, filterCurrency)\n      Vue.prototype['$' + name] = {\n        setConfig: (options) => {\n          configs = __defaults(options, defaultConfig)\n        },\n        getConfig: () => {\n          return configs\n        },\n        format: filterCurrency\n      } as CurrencyFilterMethodInstance\n    }\n\n    if (Array.isArray(pluginOptions)) {\n      pluginOptions.forEach(options => createFilter(options))\n    } else {\n      createFilter(pluginOptions!)\n    }\n  }\n}\n\nexport default VueCurrencyFilter\n"],"names":["nativeMap","Array","prototype","map","nativeIsArray","isArray","toString","Object","__isString","obj","charCodeAt","substr","__isArray","call","__isObject","__defaults","object","defs","key","hasOwnProperty","__map","iterator","context","results","i","j","length","lib","settings","currency","symbol","format","decimal","thousand","precision","grouping","number","checkPrecision","val","base","Math","round","abs","isNaN","unformat","value","regex","RegExp","unformatted","parseFloat","replace","toFixed","exponentialForm","Number","rounded","formatNumber","avoidEmptyDecimals","opts","usePrecision","negative","parseInt","mod","precisionString","split","undefined","formatMoney","formats","defaults","match","pos","neg","zero","checkCurrencyFormat","defaultConfig","name","thousandsSeparator","fractionCount","fractionSeparator","symbolPosition","symbolSpacing","VueCurrencyFilter","install","Vue","pluginOptions","createFilter","options","globalConfigs","configs","filterCurrency","_symbol","_thousandsSeparator","_fractionCount","_fractionSeparator","_symbolPosition","_symbolSpacing","_avoidEmptyDecimals","runtimeConfig","result","isNegative","String","charAt","slice","amount","formatConfig","filter","setConfig","getConfig","forEach"],"mappings":"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"}